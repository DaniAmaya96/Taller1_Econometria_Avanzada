add_header_above(c("Heterocedasticidad" = 2, "Cluster" = 2)) %>%
kable_styling(
latex_options = c("hold_position", "scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
#| echo: true
#| results: 'hide'
#--------------------------------------------------
# Housekeeping\\Codigo Susan
#--------------------------------------------------
# Semilla para replicación.
set.seed(31416)
# Cargar las librerías necesarias.
library(sandwich)
library(lmtest)
# Parámetros de la simulación
#--------------------------------------------------
# Número de individuos en la población.
n_population <- 1e7
# Número de colegios.
schools <- 100
# Número de estudiantes por colegio
stud_by_school <- n_population / schools
# Probabilidad de aparecer en la muestra.
p_sample <- 0.01
# Número de simulaciones.
n_sim <- 500
# Construir base de datos poblacional
#--------------------------------------------------
# Base para la construcción.
population <- data.frame(id = 1:n_population)
# Determinar el tratamiento.
population$D <- rbinom(n_population,
size = 1, prob = 0.5)
# Determinar un colegio para cada individuo.
population$schools <- rep(1:schools,
each = stud_by_school)
# Determinar el efecto por colegio.
population$school_effect <- c(rep(1, n_population / 2),
rep(-1, n_population / 2))
# Construir la variable de resultado.
population$Y <- population$school_effect * population$D
+ runif(n_population)
#Tomando 1000 muestras estimando modelos on errores robustos y clusterizados
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
#Para general el bucle se uso IA.
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
#Para cerrar el bucle (esta línea fue sugerida por IA)
if(i %% 100 == 0) cat("Opción B: Vuelta", i, "completada.\n")
}
#_______________________________________________________
####Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
####Calculando Intervalos de Confianza Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
#Calculando los intervalos cubren cero
#____________________________________________________________
#Verificando si cubre el cero el intervalo de robustos
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
#Verificando si cubre el cero el intervalo de cluster
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
#| echo: true
#| results: 'hide'
#Tomando 1000 muestras estimando modelos on errores robustos y clusterizados
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
#Para general el bucle se uso IA.
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
#Para cerrar el bucle (esta línea fue sugerida por IA)
if(i %% 100 == 0) cat("Opción B: Vuelta", i, "completada.\n")
}
#_______________________________________________________
####Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
####Calculando Intervalos de Confianza Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
#Calculando los intervalos cubren cero
#____________________________________________________________
#Verificando si cubre el cero el intervalo de robustos
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
#Verificando si cubre el cero el intervalo de cluster
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
##Creando tabla
library(kableExtra)
library(dplyr)
#Haciedno Data Frame
tabla_final <- data.frame(
media_rob = Media_se_robusto,
procent_cobertura_rob   = mean(cubre_cero_robusto) * 100,
media_clus = Media_se_cluster,
porcent_cobertura_clus   = mean(cubre_cero_cluster) * 100
)
tabla_final %>%
kbl(
col.names = c("V Promedio", "% Cobertura", "V Promedio", "% Cobertura"),
digits = 4,
caption = "Tabla 1: Cobertura teórica de heterocedasticidad vs clusters",
align = "c",
booktabs = TRUE
) %>%
add_header_above(c("Heterocedasticidad" = 2, "Cluster" = 2)) %>%
kable_styling(
latex_options = c("hold_position", "scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
#| echo: true
#| results: 'hide'
#--------------------------------------------------
# Housekeeping\\Codigo Susan
#--------------------------------------------------
# Semilla para replicación.
set.seed(31416)
# Cargar las librerías necesarias.
library(sandwich)
library(lmtest)
# Parámetros de la simulación
#--------------------------------------------------
# Número de individuos en la población.
n_population <- 1e7
# Número de colegios.
schools <- 100
# Número de estudiantes por colegio
stud_by_school <- n_population / schools
# Probabilidad de aparecer en la muestra.
p_sample <- 0.01
# Número de simulaciones.
n_sim <- 500
# Construir base de datos poblacional
#--------------------------------------------------
# Base para la construcción.
population <- data.frame(id = 1:n_population)
# Determinar el tratamiento.
population$D <- rbinom(n_population,
size = 1, prob = 0.5)
# Determinar un colegio para cada individuo.
population$schools <- rep(1:schools,
each = stud_by_school)
# Determinar el efecto por colegio.
population$school_effect <- c(rep(1, n_population / 2),
rep(-1, n_population / 2))
# Construir la variable de resultado.
population$Y <- population$school_effect * population$D
+ runif(n_population)
#| echo: true
#| results: 'hide'
#Tomando 1000 muestras estimando modelos on errores robustos y clusterizados
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
#Para general el bucle se uso IA.
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
#Para cerrar el bucle (esta línea fue sugerida por IA)
if(i %% 100 == 0) cat("Opción B: Vuelta", i, "completada.\n")
}
#_______________________________________________________
####Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
####Calculando Intervalos de Confianza Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
#Calculando los intervalos cubren cero
#____________________________________________________________
#Verificando si cubre el cero el intervalo de robustos
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
#Verificando si cubre el cero el intervalo de cluster
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
#| echo: true
#| results: 'hide'
#| output: FALSE
#Tomando 1000 muestras estimando modelos on errores robustos y clusterizados
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
#Para general el bucle se uso IA.
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
#Para cerrar el bucle (esta línea fue sugerida por IA)
if(i %% 100 == 0) cat("Opción B: Vuelta", i, "completada.\n")
}
#_______________________________________________________
####Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
####Calculando Intervalos de Confianza Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
#Calculando los intervalos cubren cero
#____________________________________________________________
#Verificando si cubre el cero el intervalo de robustos
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
#Verificando si cubre el cero el intervalo de cluster
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
#| echo: true
#| results: 'hide'
#| output: FALSE
#Tomando 1000 muestras estimando modelos on errores robustos y clusterizados
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
#Para general el bucle se uso IA.
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
}
#_______________________________________________________
####Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
####Calculando Intervalos de Confianza Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
#Calculando los intervalos cubren cero
#____________________________________________________________
#Verificando si cubre el cero el intervalo de robustos
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
#Verificando si cubre el cero el intervalo de cluster
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
#| echo: true
#| results: 'hide'
#Tomando 1000 muestras y estimando modelos
#___________________________________________________________________________
library(fixest) #Usammos fixest por facilidad
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
#| echo: true
#| results: 'hide'
#--------------------------------------------------
# Housekeeping\\Codigo Susan
#--------------------------------------------------
# Semilla para replicación.
set.seed(31416)
# Cargar las librerías necesarias.
library(sandwich)
library(lmtest)
# Parámetros de la simulación
#--------------------------------------------------
# Número de individuos en la población.
n_population <- 1e7
# Número de colegios.
schools <- 100
# Número de estudiantes por colegio
stud_by_school <- n_population / schools
# Probabilidad de aparecer en la muestra.
p_sample <- 0.01
# Número de simulaciones.
n_sim <- 500
# Construir base de datos poblacional
#--------------------------------------------------
# Base para la construcción.
population <- data.frame(id = 1:n_population)
# Determinar el tratamiento.
population$D <- rbinom(n_population,
size = 1, prob = 0.5)
# Determinar un colegio para cada individuo.
population$schools <- rep(1:schools,
each = stud_by_school)
# Determinar el efecto por colegio.
population$school_effect <- c(rep(1, n_population / 2),
rep(-1, n_population / 2))
# Construir la variable de resultado.
population$Y <- population$school_effect * population$D
+ runif(n_population)
#| echo: true
#| results: 'hide'
#Tomando 1000 muestras y estimando modelos
#___________________________________________________________________________
library(fixest) #Usammos fixest por facilidad
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
}
#(Para general el bucle se usó ayuda de la IA).
#_______________________________________________________
# Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Intervalo Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
#Calculando Intervalos Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
# Calculando si los intervalos cubren cero
#____________________________________________________________
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
##Creando tabla
library(kableExtra)
library(dplyr)
#Haciedno Data Frame
tabla_final <- data.frame(
media_rob = Media_se_robusto,
procent_cobertura_rob   = mean(cubre_cero_robusto) * 100,
media_clus = Media_se_cluster,
porcent_cobertura_clus   = mean(cubre_cero_cluster) * 100
)
tabla_final %>%
kbl(
col.names = c("V Promedio", "% Cobertura", "V Promedio", "% Cobertura"),
digits = 4,
caption = "Tabla 1: Cobertura teórica de heterocedasticidad vs clusters",
align = "c",
booktabs = TRUE
) %>%
add_header_above(c("Heterocedasticidad" = 2, "Cluster" = 2)) %>%
kable_styling(
latex_options = c("hold_position", "scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
