library(fixest)
library(modelsummary)
library(dplyr)
library(kableExtra)
#Importando los datos para la estimación del modelo
race_teaching_1_ <- read_dta("race_teaching (1).dta")
#Haciendo las regresion con errores heterocedasticos
Reg_Hete<-feols(sat_math ~ D, race_teaching_1_, vcov = "hetero")
#Haciendo las regresiones con cluster por colegio
Reg_Clus_School<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ school )
#Haciendo las regresiones con cluster por condado
Reg_Clus_County<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ county )
#Haciendo las regresiones con cluster por estado
Reg_Clus_State<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ state )
#Haciendo tabla autocontendia
#Definimos el mapa de coeficientes y la información visible
mapa_coeficientes <- c("D" = "Profesor Misma Raza",
"(Intercept)" = "Media sin Tratamiento")
mapa_gof <- list(list("raw" = "nobs",
"clean" = "Observaciones", "fmt" = 0),
list("raw" = "r.squared",
"clean" = "R²", "fmt" = 3))
#Generamos la tabla
modelsummary(
list(
"Robustos" = Reg_Hete,
"Cluster Coelgio" = Reg_Clus_School,
"Cluster Condado" = Reg_Clus_County ,
"Cluster Estado" = Reg_Clus_State
),
coef_map = mapa_coeficientes,
gof_map = mapa_gof,
fmt = 3,
stars = c('*' = .1, '**' = .05, '***' = .01),
title = "Tabla 1. Efecto de la asignación
racial docente en diferentes niveles cluster",
notes = list("Nota: Errores estándar entre paréntesis."),
output = "kableExtra"
) %>%
add_header_above(c(" " = 1, "Puntaje SAT" = 4)) %>%
kable_styling(
latex_options = c("hold_position",
"scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
#| echo: true
#| results: 'hide'
#--------------------------------------------------
# Housekeeping\\Codigo Susan
#--------------------------------------------------
# Semilla para replicación.
set.seed(31416)
# Cargar las librerías necesarias.
library(sandwich)
library(lmtest)
# Parámetros de la simulación
#--------------------------------------------------
# Número de individuos en la población.
n_population <- 1e7
# Número de colegios.
schools <- 100
# Número de estudiantes por colegio
stud_by_school <- n_population / schools
# Probabilidad de aparecer en la muestra.
p_sample <- 0.01
# Número de simulaciones.
n_sim <- 500
# Construir base de datos poblacional
#--------------------------------------------------
# Base para la construcción.
population <- data.frame(id = 1:n_population)
# Determinar el tratamiento.
population$D <- rbinom(n_population,
size = 1, prob = 0.5)
# Determinar un colegio para cada individuo.
population$schools <- rep(1:schools,
each = stud_by_school)
# Determinar el efecto por colegio.
population$school_effect <- c(rep(1, n_population / 2),
rep(-1, n_population / 2))
# Construir la variable de resultado.
population$Y <- population$school_effect * population$D
+ runif(n_population)
#| echo: true
#| results: 'hide'
#Tomando 1000 muestras y estimando modelos
#___________________________________________________________________________
library(fixest)
# Semilla para replicación, ponemos nuestra propia semilla :3.
set.seed(2896)
# Número de simulaciones.
n_sim1 <- 1000
#Definimos tamaño muestra.
Tamano_muestra <- n_population*p_sample
# Vectores para guardar resultados
se_robusto <- numeric(n_sim1)
se_cluster <- numeric(n_sim1)
betas      <- numeric(n_sim1)
#Construyendo bucle para hacer las estimaciones
for (i in 1:n_sim1) {
indices <- sample(1:n_population, size = Tamano_muestra)
MuestraTemporal<- population[indices, ]
modelo<- feols(Y~D, data = MuestraTemporal)
#guardamos los coeficientes
betas[i] <- coef(modelo)["D"]
#Guardamos los errores estandar
se_robusto[i]<- se(modelo, se = "hetero")["D"]
se_cluster[i]<- se(modelo, cluster= ~schools)["D"]
}
#(Para general el bucle se usó ayuda de la IA).
#_______________________________________________________
# Calculando Intervalos de Confianza
#_______________________________________________________
#Definimos valor crítico
valor_critico <- 1.96
#Calculando Intervalo Para Errores Robustos
#Limite inferior = \hatBeta- 1.96*se_robusto
ci_robusto_inf <- betas - (valor_critico * se_robusto)
#Limite superior = \hatBeta + 1.96*se_robusto
ci_robusto_sup <- betas + (valor_critico * se_robusto)
#Calculando Intervalos Para Errores Cluster
#Limite inferior = \hatBeta- 1.96*se_cluster
ci_cluster_inf <- betas - (valor_critico * se_cluster)
#Limite superior = \hatBeta + 1.96*se_cluster
ci_cluster_sup <- betas + (valor_critico * se_cluster)
#____________________________________________________________
# Calculando si los intervalos cubren cero
#____________________________________________________________
cubre_cero_robusto <- (ci_robusto_inf <= 0) & (ci_robusto_sup >= 0)
cubre_cero_cluster <- (ci_cluster_inf <= 0) & (ci_cluster_sup >= 0)
#_____________________________________________________________
#Calculando promedio de errores para los dos casos
#_____________________________________________________________
Media_se_robusto<-mean(se_robusto)
Media_se_cluster<-mean(se_cluster)
#Cargando paquetes necesarios
library(haven)
library(fixest)
library(modelsummary)
library(dplyr)
library(kableExtra)
#Importando los datos para la estimación del modelo
race_teaching_1_ <- read_dta("race_teaching (1).dta")
#Haciendo las regresiones con errores heterocedasticos
Reg_Hete_SAT<-feols(sat_math ~ D, race_teaching_1_, vcov = "hetero")
Reg_Hete_Col<-feols(college ~ D, race_teaching_1_, vcov = "hetero")
#Haciendo las regresiones con cluster por colegio
Reg_Clus_SAT<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ school )
Reg_Clus_Col<-feols(college ~ D, race_teaching_1_, vcov = ~ school)
#Haciendo tabla autocontendia
#Definimos el mapa de coeficientes y la información visible
mapa_coeficientes <- c("D" = "Profesor Misma Raza",
"(Intercept)" = "Media sin Tratamiento")
mapa_gof <- list(list("raw" = "nobs",
"clean" = "Observaciones", "fmt" = 0),
list("raw" = "r.squared",
"clean" = "R²", "fmt" = 3))
#Generamos la tabla
modelsummary(
list(
"(Robusto)" = Reg_Hete_SAT,
"(Cluster)" = Reg_Clus_SAT,
"(Robusto)" = Reg_Hete_Col,
"(Cluster)" = Reg_Clus_Col
),
coef_map = mapa_coeficientes,
gof_map = mapa_gof,
fmt = 3,
stars = c('*' = .1, '**' = .05, '***' = .01),
title = "Tabla 1. Efecto de la asignación racial docente",
notes = list("Nota: Errores estándar entre paréntesis."),
output = "kableExtra"
) %>%
add_header_above(c(" " = 1, "Puntaje SAT" = 2,
"Ingreso Universidad" = 2)) %>%
kable_styling(
latex_options = c("hold_position",
"scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
#Cargando paquetes necesarios
library(haven)
library(fixest)
library(modelsummary)
library(dplyr)
library(kableExtra)
#Importando los datos para la estimación del modelo
race_teaching_1_ <- read_dta("race_teaching (1).dta")
#Haciendo las regresion con errores heterocedasticos
Reg_Hete<-feols(sat_math ~ D, race_teaching_1_, vcov = "hetero")
#Haciendo las regresiones con cluster por colegio
Reg_Clus_School<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ school )
#Haciendo las regresiones con cluster por condado
Reg_Clus_County<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ county )
#Haciendo las regresiones con cluster por estado
Reg_Clus_State<-feols(sat_math ~ D, race_teaching_1_, vcov = ~ state )
#Haciendo tabla autocontendia
#Definimos el mapa de coeficientes y la información visible
mapa_coeficientes <- c("D" = "Profesor Misma Raza",
"(Intercept)" = "Media sin Tratamiento")
mapa_gof <- list(list("raw" = "nobs",
"clean" = "Observaciones", "fmt" = 0),
list("raw" = "r.squared",
"clean" = "R²", "fmt" = 3))
#Generamos la tabla
modelsummary(
list(
"Robustos" = Reg_Hete,
"Cluster Coelgio" = Reg_Clus_School,
"Cluster Condado" = Reg_Clus_County ,
"Cluster Estado" = Reg_Clus_State
),
coef_map = mapa_coeficientes,
gof_map = mapa_gof,
fmt = 3,
stars = c('*' = .1, '**' = .05, '***' = .01),
title = "Tabla 1. Efecto de la asignación
racial docente en diferentes niveles cluster",
notes = list("Nota: Errores estándar entre paréntesis."),
output = "kableExtra"
) %>%
add_header_above(c(" " = 1, "Puntaje SAT" = 4)) %>%
kable_styling(
latex_options = c("hold_position",
"scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
##Creando tabla
library(kableExtra)
library(dplyr)
#Haciedno Data Frame
tabla_final <- data.frame(
media_rob = Media_se_robusto,
procent_cobertura_rob   = mean(cubre_cero_robusto) * 100,
media_clus = Media_se_cluster,
porcent_cobertura_clus   = mean(cubre_cero_cluster) * 100
)
tabla_final %>%
kbl(
col.names = c("V Promedio", "% Cobertura", "V Promedio", "% Cobertura"),
digits = 4,
caption = "Tabla 1: Cobertura teórica de heterocedasticidad vs clusters",
align = "c",
booktabs = TRUE
) %>%
add_header_above(c("Heterocedasticidad" = 2, "Cluster" = 2)) %>%
kable_styling(
latex_options = c("hold_position", "scale_down", "striped"),
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE,
position = "center"
)
#| message: false
#| warning: false
#Cargando librerias
library(haven)
library(dplyr)
library(fixest)
library(kableExtra)
#Cargando los datos
baseline_sample_ <- read_dta("baseline_sample.dta")
#Nombrando las variables
baseline_sample_<- baseline_sample_ %>%
mutate(
Edad_Mujer = an_bw_s3q5_age,
Esposo_poligamo = an_bw_polygamous,
N_Hijos_desados= an_bw_s8q1_childdesired,
Uso_Actual_Anticoncep_Moderna = an_bw_modern_cmeth_curr_s11q5,
Insatisfaccion_Acceso_Anticoncep = an_unmet,
No_puede_pagar_anticoncep= an_able_contra,
Hogar_Con_Radio=bw_s2q19a_radioyn,
D_i= arm_free,
Centro_Salud = new_csps
)
#Estimando las regresiones
reg1<-feols(Edad_Mujer~ D_i | PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg2<-feols(Esposo_poligamo~ D_i | PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg3<-feols(N_Hijos_desados~ D_i |  PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg4<-feols(Uso_Actual_Anticoncep_Moderna~ D_i |  PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg5<-feols(Insatisfaccion_Acceso_Anticoncep~ D_i |  PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg6 <- feols(No_puede_pagar_anticoncep~ D_i |  PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
reg7 <- feols(Hogar_Con_Radio~ D_i |  PROVINCE ,
baseline_sample_, vcov = ~ Centro_Salud )
#Calculando estadistico F conjunto
reg_f <- feols(D_i ~ Edad_Mujer + Esposo_poligamo
+ N_Hijos_desados +
Uso_Actual_Anticoncep_Moderna
+ Insatisfaccion_Acceso_Anticoncep +
No_puede_pagar_anticoncep
+ Hogar_Con_Radio | PROVINCE,
data = baseline_sample_,
vcov = ~ Centro_Salud)
invisible(capture.output(test_conjunto <- wald(reg_f)))
f_stat <- test_conjunto$stat
f_pval <- test_conjunto$p
#Se revisó en el material de replicación
#se identificó que el cluster por new_csps corresponde a centro de salud
#en el codebook no era claro.
# Preparando vectores para la tabla
modelos <- list(reg1, reg2, reg3, reg4, reg5, reg6, reg7)
var_nombres <- c("Edad de la mujer",
"La mujer reporta que su esposo es polígamo",
"Número total de hijos deseados por la mujer",
"Uso actual de anticoncepción moderna",
"Necesidad de la mujer por anticonceptivos está insatisfecha",
"No podría pagar por anticonceptivos si quisiera usarlos",
"El hogar tiene radio")
var_datos <- c("Edad_Mujer", "Esposo_poligamo", "N_Hijos_desados",
"Uso_Actual_Anticoncep_Moderna", "Insatisfaccion_Acceso_Anticoncep",
"No_puede_pagar_anticoncep", "Hogar_Con_Radio")
# Creando matriz vacia para llenarla con un loop
resultados <- matrix(ncol = 6, nrow = 0)
# --- Loop Corregido ---
for(i in 1:7) {
m <- modelos[[i]]
v <- var_datos[i]
# Medias grupo control y tratamiento
media_c <- mean(baseline_sample_[[v]][baseline_sample_$D_i == 0], na.rm = TRUE)
media_t <- mean(baseline_sample_[[v]][baseline_sample_$D_i == 1], na.rm = TRUE)
# EXTRACCIÓN SEGURA: Sacamos la tabla de coeficientes del modelo
tabla_coefs <- summary(m)$coeftable
coef_val <- tabla_coefs["D_i", "Estimate"]
se_val   <- tabla_coefs["D_i", "Std. Error"]
pval_val <- tabla_coefs["D_i", "Pr(>|t|)"]
# Fila 1: Coeficiente e info
fila_coef <- c(var_nombres[i],
round(media_c, 3),
round(media_t, 3),
nobs(m),
round(coef_val, 3),
round(pval_val, 3))
# Fila 2: Error Estandar
fila_se <- c("", "", "", "", paste0("(", round(se_val, 3), ")"), "")
resultados <- rbind(resultados, fila_coef, fila_se)
}
# Agregando el F al final de la matriz
resultados <- rbind(resultados,
c("", "", "", "", "", ""),
c("Estadístico F conjunto", "", "", "", round(f_stat, 3), round(f_pval, 3)))
# Convirtiendo a data.frame garantizando que todo sea texto/número simple
tabla_df <- as.data.frame(resultados, row.names = FALSE)
names(tabla_df) <- c("Variable", "Control", "Tratamiento", "N", "Coeficiente / (EE)", "Valor-p")
# 3. Construir y estilizar la tabla con kableExtra
tabla_balance <- tabla_df %>%
kbl(
col.names = c("Variable", "Control", "Tratamiento", "N", "Coeficiente / (EE)", "Valor-p"),
align = c("l", "c", "c", "c", "c", "c"),
caption = "Tabla A.1: Pruebas de balance en la encuesta de línea base",
booktabs = TRUE
) %>%
add_header_above(c(" " = 1, "Medias (Línea Base)" = 2, " " = 1, "Diferencias" = 2)) %>%
kable_styling(
latex_options = c("hold_position", "scale_down"),
bootstrap_options = c("hover", "condensed"),
full_width = FALSE,
position = "center"
) %>%
footnote(
general = "EE agrupados a nivel de centro de salud entre paréntesis.",
general_title = "Nota: ",
footnote_as_chunk = TRUE
)
tabla_balance
#Cargando Librerias
library(dplyr)
library(haven)
library(fixest)
library(kableExtra)
#Cargando los datos
baseline<- read_dta("baseline_sample.dta")
endline <- read_dta("endline_sample.dta")
#Haciendo el merge de las bases y calculando atrición
#Seleccionando vars Endline
endline_listo <- endline %>%
mutate(estuvo_endline = 1) %>%
select(
new_womid_final,
estuvo_endline,
an_ew_any_deliveries_ab_s7q4,
an_ew_at_least_1preg_ab,
an_ew_contra_modern_lst3y,
an_ew_coupon_use_s15q7,
ew_survey_date,
)
# Uniendo
datos_completos <- baseline %>%
left_join(endline_listo, by = "new_womid_final")
datos_completos <- datos_completos %>%
mutate(atricion = ifelse(is.na(estuvo_endline), 1, 0))
datos_completos <- datos_completos %>%
mutate(
Y1_nacimiento = an_ew_any_deliveries_ab_s7q4,
Y2_embarazo   = an_ew_at_least_1preg_ab,
Y3_uso_anti   = an_ew_contra_modern_lst3y,
Y4_cupon      = an_ew_coupon_use_s15q7,
D_i           = arm_free
)
# Atrición por grupo de tratamiento
atricion_grupos <- datos_completos %>%
group_by(D_i) %>%
summarise(
`N Inicial` = n(),
`N Atrición` = sum(atricion),
`Tasa de Atrición (%)` = round(mean(atricion) * 100, 2)
) %>%
mutate(Grupo = ifelse(D_i == 1, "Tratamiento (100%)", "Control (10%)")) %>%
select(Grupo, `N Inicial`, `N Atrición`, `Tasa de Atrición (%)`)
# Atrición Total
atricion_total <- datos_completos %>%
summarise(
Grupo = "Total Muestra",
`N Inicial` = n(),
`N Atrición` = sum(atricion),
`Tasa de Atrición (%)` = round(mean(atricion) * 100, 2)
)
# Unimos las filas para crear la tabla final
tabla_atricion <- bind_rows(atricion_grupos, atricion_total)
#generando tabla
# Generamos la tabla para el PDF con kableExtra
tabla_atricion %>%
kbl(
caption = "Tasa de Atrición entre Línea Base y Seguimiento",
align = c("l", "c", "c", "c"),
booktabs = TRUE
) %>%
kable_styling(
latex_options = "hold_position",
bootstrap_options = "condensed",
full_width = FALSE
)
#| message: false
#| warning: false
# Cargando librerías
library(dplyr)
library(haven)
library(fixest)
library(modelsummary)
library(kableExtra)
# Definimos el vector covariables
controles <- "an_bw_s3q5_age + an_bw_polygamous + an_bw_s8q1_childdesired + an_bw_modern_cmeth_curr_s11q5 + ew_survey_date + TELEPHONIQUE_endline"
# Estimamos los modelos
reg_itt1 <- feols(as.formula(paste("Y1_nacimiento ~ D_i +",
controles, "| PROVINCE")),
data = datos_completos, vcov = ~ new_csps)
reg_itt2 <- feols(as.formula(paste("Y2_embarazo ~ D_i +",
controles, "| PROVINCE")),
data = datos_completos, vcov = ~ new_csps)
reg_itt3 <- feols(as.formula(paste("Y3_uso_anti ~ D_i +",
controles, "| PROVINCE")),
data = datos_completos, vcov = ~ new_csps)
reg_itt4 <- feols(as.formula(paste("Y4_cupon ~ D_i +",
controles, "| PROVINCE")),
data = datos_completos, vcov = ~ new_csps)
# Calculando medias grupo control para tabla
mean_y1 <- mean(datos_completos$Y1_nacimiento[datos_completos$D_i == 0],
na.rm = TRUE)
mean_y2 <- mean(datos_completos$Y2_embarazo[datos_completos$D_i == 0],
na.rm = TRUE)
mean_y3 <- mean(datos_completos$Y3_uso_anti[datos_completos$D_i == 0],
na.rm = TRUE)
mean_y4 <- mean(datos_completos$Y4_cupon[datos_completos$D_i == 0],
na.rm = TRUE)
# Sacando las observaciones de los modelos para tabla
obs_1 <- nobs(reg_itt1)
obs_2 <- nobs(reg_itt2)
obs_3 <- nobs(reg_itt3)
obs_4 <- nobs(reg_itt4)
# Dando forma a la parte inferior de la tabla
filas_extra <- data.frame(
term = c("Controles de línea base", "Efectos fijos (Provincia)",
"Observaciones", "Media del control (10%)"),
reg1 = c("Sí", "Sí", as.character(obs_1), sprintf("%.3f", mean_y1)),
reg2 = c("Sí", "Sí", as.character(obs_2), sprintf("%.3f", mean_y2)),
reg3 = c("Sí", "Sí", as.character(obs_3), sprintf("%.3f", mean_y3)),
reg4 = c("Sí", "Sí", as.character(obs_4), sprintf("%.3f", mean_y4))
)
# Generando tabla
mapa_coef <- c("D_i" = "Subsidio Completo (100%)")
modelsummary(
list(
"(1) Tuvo Nacimiento"     = reg_itt1,
"(2) Tuvo Embarazo"       = reg_itt2,
"(3) Usó Anticoncepción" = reg_itt3,
"(4) Usó Cupón"      = reg_itt4
),
coef_map = mapa_coef,
stars = c('*' = .1, '**' = .05, '***' = .01),
gof_omit = ".*",
add_rows = filas_extra,
title = "Tabla 2. Efectos del tratamiento resultados principales",
notes = list("Nota: Errores estándar clusterizados
a nivel de centro de salud entre paréntesis.
Réplica basada en Panel B (Dupas et al., 2025)."),
output = "kableExtra"
) %>%
kable_styling(
latex_options = c("hold_position", "scale_down", "booktabs"),
bootstrap_options = "condensed",
full_width = FALSE
)
